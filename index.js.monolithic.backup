// =============================================================================
// DEPENDENCIES
// =============================================================================
const express = require('express');
const cors = require('cors');
const morgan = require('morgan');
require('dotenv').config();

// =============================================================================
// ROUTE IMPORTS
// =============================================================================
const authRoutes = require('./routes/auth');
const agentRoutes = require('./routes/agent');
const adminRoutes = require('./routes/admin');
const managerRoutes = require('./routes/manager');
const publicRoutes = require('./routes/public');

// =============================================================================
// MIDDLEWARE IMPORTS
// =============================================================================
const { verifyToken } = require('./middleware/auth');

// =============================================================================
// APPLICATION CONFIGURATION
// =============================================================================
const app = express();
const PORT = process.env.PORT || 5000;

// =============================================================================
// MIDDLEWARE SETUP
// =============================================================================
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(morgan('dev'));

// =============================================================================
// API ROUTES
// =============================================================================
// Public routes (no authentication required)
app.use('/api/auth', authRoutes);
app.use('/api/public', publicRoutes);

// Protected routes (JWT authentication required)
app.use('/api/agent', verifyToken, agentRoutes);
app.use('/api/admin', verifyToken, adminRoutes);
app.use('/api/manager', verifyToken, managerRoutes);

// Health check endpoint
app.get('/api/health', async (req, res) => {
  res.status(200).json({
    status: 'success',
    message: 'B-Trust Microbanking System API is running',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development'
  });
});

// =============================================================================
// ERROR HANDLING
// =============================================================================
// 404 handler - catch all unmatched routes
app.use((req, res, next) => {
  res.status(404).json({
    status: 'error',
    message: `Route ${req.originalUrl} not found`
  });
});

// Global error handler
app.use((err, req, res, next) => {
  console.error('Error occurred:', {
    message: err.message,
    stack: err.stack,
    timestamp: new Date().toISOString()
  });

  res.status(err.status || 500).json({
    status: 'error',
    message: err.message || 'Internal server error',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
});

// =============================================================================
// SERVER INITIALIZATION
// =============================================================================
app.listen(PORT, () => {
  console.log('='.repeat(60));
  console.log('ðŸš€ B-Trust Microbanking System API Server');
  console.log('='.repeat(60));
  console.log(`ðŸ“ Server running on port: ${PORT}`);
  console.log(`ðŸŒ Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`â° Started at: ${new Date().toISOString()}`);
  console.log('='.repeat(60));
});

// PostgreSQL connection
const pool = new Pool({
  user: process.env.DB_USER || 'postgres',
  host: process.env.DB_HOST || 'localhost',
  database: process.env.DB_NAME || 'newdb',
  password: process.env.DB_PASSWORD || 'praveen123',
  port: process.env.DB_PORT || 5432,
});

// Test database connection
pool.connect((err, client, release) => {
  if (err) {
    console.error('Database connection failed: ' + err.stack);
    return;
  }
  console.log('Connected to PostgreSQL database');
  release();
});

const cron = require('node-cron');

// =============================================================================
// OPTIMIZED: FD Interest Processing using Database Functions
// =============================================================================
const processDailyFDInterest = async () => {
  console.log('ðŸš€ Starting daily FD interest processing (30-day per-account cycles)...');
  
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    const today = new Date();
    const processDate = today.toISOString().split('T')[0];

    // Use database function to get only FDs due for interest today
    const interestCalculations = await client.query(
      `SELECT * FROM calculate_fd_interest_due($1)`,
      [processDate]
    );

    let creditedCount = 0;
    let totalInterest = 0;

    // Process each calculation
    for (const calc of interestCalculations.rows) {
      if (calc.interest_amount > 0) {
        try {
          // Use the transaction function for consistency
          await client.query(
            `SELECT create_transaction_with_validation($1, $2, $3, $4, $5)`,
            ['Interest', calc.interest_amount, 
             `Monthly FD Interest - ${calc.interest_rate}% Plan`, 
             calc.linked_account_id, 1] // Using admin ID 1
          );

          // Record the calculation
          await client.query(
            `INSERT INTO fd_interest_calculations 
             (fd_id, calculation_date, interest_amount, days_in_period, credited_to_account_id, status, credited_at)
             VALUES ($1, $2, $3, $4, $5, 'credited', $6)`,
            [calc.fd_id, processDate, calc.interest_amount, calc.days_in_period, 
             calc.linked_account_id, today]
          );

          creditedCount++;
          totalInterest += parseFloat(calc.interest_amount);

          console.log(`ðŸ’° Credited LKR ${calc.interest_amount} interest for FD ${calc.fd_id} to account ${calc.linked_account_id}`);

        } catch (error) {
          console.error(`âŒ Failed to process interest for FD ${calc.fd_id}:`, error);
          await client.query(
            `INSERT INTO fd_interest_calculations 
             (fd_id, calculation_date, interest_amount, days_in_period, credited_to_account_id, status)
             VALUES ($1, $2, $3, $4, $5, 'failed')`,
            [calc.fd_id, processDate, calc.interest_amount, calc.days_in_period, calc.linked_account_id]
          );
        }
      }
    }

    // Process matured FDs using database function
    const maturedResult = await client.query('SELECT * FROM process_matured_fixed_deposits()');
    const maturedData = maturedResult.rows[0];

    await client.query('COMMIT');
    
    console.log(`âœ… Daily FD interest processing completed!`);
    console.log(`ðŸ“Š FDs Processed: ${creditedCount}`);
    console.log(`ðŸ’° Total Interest Credited: LKR ${totalInterest.toLocaleString()}`);
    console.log(`ðŸ Matured FDs Processed: ${maturedData.processed_count}`);
    console.log(`ðŸ’µ Principal Returned: LKR ${maturedData.total_principal_returned.toLocaleString()}`);

    return {
      success: true,
      processed: creditedCount,
      totalInterest: totalInterest,
      maturedProcessed: maturedData.processed_count,
      principalReturned: maturedData.total_principal_returned,
      period: processDate
    };

  } catch (error) {
    await client.query('ROLLBACK');
    console.error('âŒ Error in optimized FD interest processing:', error);
    return { success: false, error: error.message };
  } finally {
    client.release();
  }
};

// =============================================================================
// OPTIMIZED: Savings Interest Processing using Database Functions
// =============================================================================
const processDailySavingsInterest = async () => {
  console.log('ðŸš€ Starting daily savings interest processing (30-day per-account cycles)...');
  
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    const today = new Date();
    const processDate = today.toISOString().split('T')[0];

    // Use database function to get only savings accounts due for interest today
    const interestCalculations = await client.query(
      `SELECT * FROM calculate_savings_interest_due($1)`,
      [processDate]
    );

    let creditedCount = 0;
    let totalInterest = 0;

    // Process each calculation
    for (const calc of interestCalculations.rows) {
      if (calc.interest_amount > 0) {
        try {
          // Use the transaction function for consistency
          await client.query(
            `SELECT create_transaction_with_validation($1, $2, $3, $4, $5)`,
            ['Interest', calc.interest_amount, 
             `Monthly Savings Interest - ${calc.plan_type} Plan`, 
             calc.account_id, 1] // Using admin ID 1
          );

          // Record the calculation
          await client.query(
            `INSERT INTO savings_interest_calculations 
             (account_id, calculation_date, interest_amount, interest_rate, plan_type, status, credited_at)
             VALUES ($1, $2, $3, $4, $5, 'credited', $6)`,
            [calc.account_id, processDate, calc.interest_amount, calc.interest_rate, calc.plan_type, today]
          );

          creditedCount++;
          totalInterest += parseFloat(calc.interest_amount);

          console.log(`ðŸ’° Credited LKR ${calc.interest_amount} interest for account ${calc.account_id} (${calc.plan_type})`);

        } catch (error) {
          console.error(`âŒ Failed to process interest for account ${calc.account_id}:`, error);
          await client.query(
            `INSERT INTO savings_interest_calculations 
             (account_id, calculation_date, interest_amount, interest_rate, plan_type, status)
             VALUES ($1, $2, $3, $4, $5, 'failed')`,
            [calc.account_id, processDate, calc.interest_amount, calc.interest_rate, calc.plan_type]
          );
        }
      }
    }

    await client.query('COMMIT');
    
    console.log(`âœ… Daily savings interest processing completed!`);
    console.log(`ðŸ“Š Accounts Processed: ${creditedCount}`);
    console.log(`ðŸ’° Total Interest Credited: LKR ${totalInterest.toLocaleString()}`);
    console.log(`ðŸ“… Date: ${processDate}`);

    return {
      success: true,
      processed: creditedCount,
      totalInterest: totalInterest,
      period: processDate
    };

  } catch (error) {
    await client.query('ROLLBACK');
    console.error('âŒ Error in optimized savings interest processing:', error);
    return { success: false, error: error.message };
  } finally {
    client.release();
  }
};

// Scheduling configuration
// Default daily schedules, but allow override via env for testing
// Set INTEREST_CRON_DEBUG=1 to run both every minute temporarily
const FD_CRON = process.env.FD_INTEREST_CRON || (process.env.INTEREST_CRON_DEBUG === '1' ? '* * * * *' : '0 3 * * *');
const SAVINGS_CRON = process.env.SAVINGS_INTEREST_CRON || (process.env.INTEREST_CRON_DEBUG === '1' ? '* * * * *' : '30 3 * * *');

cron.schedule(FD_CRON, processDailyFDInterest); // FD interest
cron.schedule(SAVINGS_CRON, processDailySavingsInterest); // Savings interest

if (process.env.INTEREST_CRON_DEBUG === '1') {
  console.warn(`âš ï¸ Interest processors set to DEBUG mode (every minute). Disable by unsetting INTEREST_CRON_DEBUG.`);
}
console.log(`âœ… FD Interest Auto-Processor: Scheduled '${FD_CRON}'`);
console.log(`âœ… Savings Interest Auto-Processor: Scheduled '${SAVINGS_CRON}'`);

// =============================================================================
// OPTIMIZED: Transaction Processing using Database Functions
// =============================================================================
app.post('/api/agent/transactions/process', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const { account_id, transaction_type, amount, description } = req.body;

    // Validation
    if (!account_id || !transaction_type || amount === undefined || !description) {
      return res.status(400).json({ message: 'All fields are required' });
    }

    if (amount <= 0) {
      return res.status(400).json({ message: 'Amount must be positive' });
    }

    const client = await pool.connect();

    try {
      await client.query('BEGIN');
      // Set actor id for downstream DB audit triggers (if used)
      await client.query("SELECT set_config('app.actor_employee_id', $1, true)", [decoded.id.toString()]);

      // Check if account exists and is active
      const accountResult = await client.query(
        'SELECT * FROM account WHERE account_id = $1 AND account_status = $2',
        [account_id, 'Active']
      );

      if (accountResult.rows.length === 0) {
        await client.query('ROLLBACK');
  return res.status(400).json({ message: 'Account not found or closed' });
      }

      // OPTIMIZED: Use database function for transaction processing
      const transactionResult = await client.query(
        'SELECT create_transaction_with_validation($1, $2, $3, $4, $5) as transaction_id',
        [transaction_type, amount, description, account_id, decoded.id]
      );

      // Get updated balance
      const balanceResult = await client.query(
        'SELECT balance FROM account WHERE account_id = $1',
        [account_id]
      );

      await client.query('COMMIT');
      
      res.status(201).json({ 
        message: 'Transaction processed successfully',
        transaction_id: transactionResult.rows[0].transaction_id,
        new_balance: parseFloat(balanceResult.rows[0].balance)
      });
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Database error:', error);
      
      // Handle specific database function errors
      if (error.message.includes('Insufficient balance') || 
          error.message.includes('Minimum balance required')) {
        return res.status(400).json({ message: error.message });
      }
      
      res.status(500).json({ message: 'Database error: ' + error.message });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// =============================================================================
// Manager: Customer search within manager's branch (by name or NIC only)
// =============================================================================
app.get('/api/manager/customers/search', async (req, res) => {
  // Verify manager authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Manager' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Manager access required' });
    }

    const { query } = req.query;
    if (!query || String(query).trim().length === 0) {
      return res.status(400).json({ message: 'Search query is required' });
    }

    const client = await pool.connect();
    try {
      // Determine manager's branch
      const managerResult = await client.query(
        'SELECT branch_id FROM employee WHERE employee_id = $1',
        [decoded.id]
      );

      if (managerResult.rows.length === 0) {
        return res.status(404).json({ message: 'Manager not found' });
      }

      const branchId = managerResult.rows[0].branch_id;

      // Search customers linked to accounts in this branch by name or NIC
      const q = `%${query}%`;
      const result = await client.query(
        `SELECT 
            c.customer_id,
            c.first_name,
            c.last_name,
            c.gender,
            c.nic,
            c.date_of_birth,
            ct.contact_no_1,
            ct.contact_no_2,
            ct.email,
            ct.address,
            COUNT(DISTINCT a.account_id) AS accounts_count,
            ARRAY_AGG(DISTINCT a.account_id) AS account_ids
         FROM customer c
         JOIN contact ct ON c.contact_id = ct.contact_id
         JOIN takes t ON c.customer_id = t.customer_id
         JOIN account a ON t.account_id = a.account_id
         WHERE a.branch_id = $1
           AND (
             c.first_name ILIKE $2 OR 
             c.last_name ILIKE $2 OR 
             (c.first_name || ' ' || c.last_name) ILIKE $2 OR
             (c.last_name || ' ' || c.first_name) ILIKE $2 OR
             c.nic ILIKE $2
           )
         GROUP BY c.customer_id, ct.contact_no_1, ct.contact_no_2, ct.email, ct.address
         ORDER BY c.last_name, c.first_name
         LIMIT 50`,
        [branchId, q]
      );

      res.json({ customers: result.rows });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// =============================================================================
// OPTIMIZED: Fixed Deposit Creation using Database Functions
// =============================================================================
app.post('/api/agent/fixed-deposits/create', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const { customer_id, account_id, fd_plan_id, principal_amount, auto_renewal_status } = req.body;

    // Validation
    if (!customer_id || !account_id || !fd_plan_id || principal_amount === undefined) {
      return res.status(400).json({ message: 'All required fields must be provided' });
    }

    if (principal_amount <= 0) {
      return res.status(400).json({ message: 'Principal amount must be greater than 0' });
    }

    const client = await pool.connect();

    try {
      await client.query('BEGIN');

      // Verify customer exists and is at least 18 years old
      const customerResult = await client.query(
        'SELECT *, EXTRACT(YEAR FROM AGE(date_of_birth)) as age FROM customer WHERE customer_id = $1',
        [customer_id]
      );
      if (customerResult.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(400).json({ message: 'Customer not found' });
      }

      const customer = customerResult.rows[0];
      if (parseInt(customer.age) < 18) {
        await client.query('ROLLBACK');
        return res.status(400).json({ message: 'Customer must be at least 18 years old for Fixed Deposit' });
      }

      // Verify account exists and get details
      const accountResult = await client.query(
        `SELECT a.*, sp.min_balance, sp.plan_type 
         FROM account a 
         JOIN savingplan sp ON a.saving_plan_id = sp.saving_plan_id 
         WHERE a.account_id = $1 AND a.account_status = $2`,
        [account_id, 'Active']
      );
      if (accountResult.rows.length === 0) {
        await client.query('ROLLBACK');
  return res.status(400).json({ message: 'Account not found or closed' });
      }

      const account = accountResult.rows[0];
      const minBalance = parseFloat(account.min_balance);
      const availableForFD = parseFloat(account.balance) - minBalance;

      if (parseFloat(principal_amount) > availableForFD) {
        await client.query('ROLLBACK');
        return res.status(400).json({ 
          message: `Insufficient balance. Maximum FD amount: LKR ${availableForFD.toFixed(2)}. Minimum balance of LKR ${minBalance.toFixed(2)} must remain in savings account for ${account.plan_type} plan` 
        });
      }

      // Verify FD plan exists
      const planResult = await client.query('SELECT * FROM fdplan WHERE fd_plan_id = $1', [fd_plan_id]);
      if (planResult.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(400).json({ message: 'Invalid FD plan' });
      }

      const fdPlan = planResult.rows[0];

      // Calculate maturity date
      const openDate = new Date();
      const maturityDate = new Date(openDate);
      
      switch (fdPlan.fd_options) {
        case '6 months':
          maturityDate.setMonth(openDate.getMonth() + 6);
          break;
        case '1 year':
          maturityDate.setFullYear(openDate.getFullYear() + 1);
          break;
        case '3 years':
          maturityDate.setFullYear(openDate.getFullYear() + 3);
          break;
      }

      // Create fixed deposit record
      const fdResult = await client.query(
        `INSERT INTO fixeddeposit (fd_balance, auto_renewal_status, fd_status, open_date, maturity_date, fd_plan_id)
         VALUES ($1, $2, $3, $4, $5, $6)
         RETURNING fd_id`,
        [principal_amount, auto_renewal_status, 'Active', openDate, maturityDate, fd_plan_id]
      );

      const fdId = fdResult.rows[0].fd_id;

      // OPTIMIZED: Use database function for the withdrawal transaction
      await client.query(
        'SELECT create_transaction_with_validation($1, $2, $3, $4, $5)',
        ['Withdrawal', principal_amount, 
         `Fixed Deposit Creation - ${fdPlan.fd_options} Plan`, account_id, decoded.id]
      );

      // Link FD to account
      await client.query(
        'UPDATE account SET fd_id = $1 WHERE account_id = $2',
        [fdId, account_id]
      );

      // Get updated balance
      const updatedAccount = await client.query(
        'SELECT balance FROM account WHERE account_id = $1',
        [account_id]
      );

      await client.query('COMMIT');
      
      res.status(201).json({ 
        message: 'Fixed Deposit created successfully',
        fd_id: fdId,
        maturity_date: maturityDate.toISOString().split('T')[0],
        new_savings_balance: parseFloat(updatedAccount.rows[0].balance)
      });
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error: ' + error.message });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// =============================================================================
// OPTIMIZED: Account Deactivation using Database Functions
// =============================================================================
app.post('/api/agent/accounts/deactivate', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const { account_id, reason } = req.body;

    if (!account_id) {
      return res.status(400).json({ message: 'Account ID is required' });
    }

    const client = await pool.connect();

    try {
      await client.query('BEGIN');

      // Check if account exists and is active
      const accountResult = await client.query(
        'SELECT * FROM account WHERE account_id = $1 AND account_status = $2',
        [account_id, 'Active']
      );

      if (accountResult.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(400).json({ message: 'Active account not found' });
      }

      const account = accountResult.rows[0];

      // Check if account has an active FD
      if (account.fd_id) {
        const fdResult = await client.query(
          'SELECT * FROM fixeddeposit WHERE fd_id = $1 AND fd_status = $2',
          [account.fd_id, 'Active']
        );
        
        if (fdResult.rows.length > 0) {
          await client.query('ROLLBACK');
          return res.status(400).json({ 
            message: 'Cannot deactivate account with active Fixed Deposit. Please deactivate the FD first.' 
          });
        }
      }

      let withdrawalAmount = parseFloat(account.balance);
      let withdrawalTransactionId = null;

      // If account has balance, perform a direct closure withdrawal bypassing min balance validation
      if (withdrawalAmount > 0) {
        // Allow guarded direct balance update for this account in this transaction
        await client.query("SELECT set_config('app.balance_update_allowed','true', true)");
        await client.query("SELECT set_config('app.balance_update_account_id', $1, true)", [account_id.toString()]);
        // 1) Set account balance to zero directly (allowed by trigger as long as non-negative)
        await client.query(
          'UPDATE account SET balance = $1 WHERE account_id = $2',
          [0, account_id]
        );

        // 2) Record the withdrawal as a transaction (audit trigger validates basic constraints)
        const txResult = await client.query(
          `INSERT INTO transaction (transaction_type, amount, time, description, account_id, employee_id)
           VALUES ($1, $2, $3, $4, $5, $6)
           RETURNING transaction_id`,
          ['Withdrawal', withdrawalAmount, new Date(), 
           `Account Closure - Full Balance Withdrawal - ${reason || 'No reason provided'}`,
           account_id, decoded.id]
        );
        withdrawalTransactionId = txResult.rows[0].transaction_id;
      }

      // Update account to permanently closed
      await client.query(
        'UPDATE account SET account_status = $1, closed_at = $2 WHERE account_id = $3',
        ['Closed', new Date(), account_id]
      );

      await client.query('COMMIT');
      
      const responseData = { 
        message: 'Account deactivated successfully',
        account_id: account_id,
        previous_status: 'Active',
  new_status: 'Closed',
        previous_balance: withdrawalAmount,
        final_balance: 0
      };

      if (withdrawalAmount > 0) {
        responseData.withdrawal_amount = withdrawalAmount;
        responseData.withdrawal_transaction_id = withdrawalTransactionId;
        responseData.message += ` Full balance of LKR ${withdrawalAmount.toLocaleString()} withdrawn and account closed.`;
      } else {
        responseData.message += ' Account closed with zero balance.';
      }

      res.json(responseData);
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error: ' + error.message });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// =============================================================================
// Manual triggers for interest processing (using optimized versions)
// =============================================================================

// =============================================================================
// Refresh Materialized Views Endpoint
// =============================================================================
app.post('/api/admin/refresh-views', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Admin access required' });
    }

    const client = await pool.connect();
    try {
      await client.query('SELECT refresh_materialized_views()');
      res.json({ message: 'Materialized views refreshed successfully' });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// =============================================================================
// KEEP ALL YOUR EXISTING ENDPOINTS BELOW - They remain unchanged
// =============================================================================

// Admin-only registration endpoint
app.post('/api/admin/register', async (req, res) => {
  // Verify admin authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Admin access required' });
    }

    const { 
      role, 
      username, 
      password, 
      first_name, 
      last_name, 
      nic, 
      gender, 
      date_of_birth, 
      branch_id,
      // Contact fields
      contact_no_1,
      contact_no_2,
      address,
      email
    } = req.body;

    // Validation - check required fields
    if (!username || !password || !first_name || !last_name || !nic || !gender || !date_of_birth || !branch_id) {
      return res.status(400).json({ message: 'All basic fields are required' });
    }

    // Contact validation
    if (!contact_no_1 || !address || !email) {
      return res.status(400).json({ message: 'All contact fields are required' });
    }

    // Enforce 18+ for employee roles (Admin/Manager/Agent)
    try {
      const dob = new Date(date_of_birth);
      const today = new Date();
      let age = today.getFullYear() - dob.getFullYear();
      const m = today.getMonth() - dob.getMonth();
      if (m < 0 || (m === 0 && today.getDate() < dob.getDate())) age--;
      if (age < 18) {
        return res.status(400).json({ message: 'Employee must be at least 18 years old' });
      }
    } catch (e) {
      return res.status(400).json({ message: 'Invalid date_of_birth' });
    }

    const client = await pool.connect();

    try {
      await client.query('BEGIN');

      // Check if username already exists
      const checkUserQuery = 'SELECT * FROM employee WHERE username = $1';
      const userResult = await client.query(checkUserQuery, [username]);
      
      if (userResult.rows.length > 0) {
        await client.query('ROLLBACK');
        return res.status(400).json({ message: 'Username already exists' });
      }

      // Create contact record (auto-generated ID)
      const insertContactQuery = `
        INSERT INTO contact (type, contact_no_1, contact_no_2, address, email)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING contact_id
      `;
      
      const contactResult = await client.query(insertContactQuery, [
        'employee', 
        contact_no_1, 
        contact_no_2 || null, 
        address, 
        email
      ]);
      
      const contact_id = contactResult.rows[0].contact_id;

      // Hash password
      const hashedPassword = await bcrypt.hash(password, 10);

      // Insert new employee (auto-generated ID)
      const insertEmployeeQuery = `
        INSERT INTO employee (role, username, password, first_name, last_name, nic, gender, date_of_birth, branch_id, contact_id)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING employee_id
      `;
      
      const insertResult = await client.query(insertEmployeeQuery, [
        role, username, hashedPassword, first_name, last_name, 
        nic, gender, date_of_birth, branch_id, contact_id
      ]);

      await client.query('COMMIT');
      
      res.status(201).json({ 
        message: 'User created successfully',
        employee_id: insertResult.rows[0].employee_id,
        contact_id: contact_id
      });
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error: ' + error.message });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// Login endpoint
app.post('/api/login', async (req, res) => {
  const { username, password } = req.body;

  console.log('Login attempt:', username);

  const client = await pool.connect();

  try {
    const query = 'SELECT * FROM employee WHERE username = $1';
    const result = await client.query(query, [username]);
    
    if (result.rows.length === 0) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    const user = result.rows[0];
    
    // Compare password with bcrypt
    const isMatch = await bcrypt.compare(password, user.password);
    
    if (!isMatch) {
      console.log('Password does not match');
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    // Create token
    const token = jwt.sign(
      { id: user.employee_id, role: user.role },
      process.env.JWT_SECRET || 'hey',
      { expiresIn: '1h' }
    );

    res.json({
      token,
      user: {
        id: user.employee_id,
        username: user.username,
        first_name: user.first_name,
        last_name: user.last_name,
        role: user.role
      }
    });
  } catch (error) {
    console.error('Database error:', error);
    res.status(500).json({ message: 'Database error' });
  } finally {
    client.release();
  }
});


// Get all users
app.get('/api/admin/users', async (req, res) => {
  // Verify admin authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Admin access required' });
    }

    const client = await pool.connect();
    try {
      const result = await client.query(
        'SELECT employee_id, username, first_name, last_name, role, nic, gender, date_of_birth, branch_id, contact_id, created_at FROM employee ORDER BY created_at DESC'
      );
      
      res.json({ users: result.rows });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});


// DELETE user
app.delete('/api/admin/users/:id', async (req, res) => {
  // Verify admin authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Admin access required' });
    }

    const { id } = req.params;
    const client = await pool.connect();
    
    try {
      const result = await client.query('DELETE FROM employee WHERE employee_id = $1', [id]);
      
      if (result.rowCount === 0) {
        return res.status(404).json({ message: 'User not found' });
      }
      
      res.json({ message: 'User deleted successfully' });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});


// Test endpoint
app.get('/api/test', (req, res) => {
  res.json({ message: 'Server is working!' });
});

// Health check endpoint
app.get('/api/health', async (req, res) => {
  try {
    const result = await pool.query('SELECT NOW() as current_time');
    res.json({ 
      message: 'Server and database are running', 
      status: 'OK',
      database_time: result.rows[0].current_time
    });
  } catch (error) {
    res.status(500).json({ 
      message: 'Database connection failed', 
      status: 'ERROR' 
    });
  }
});


// Branch Management APIs
app.get('/api/admin/branches', async (req, res) => {
  // Verify admin authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Admin access required' });
    }

    const client = await pool.connect();
    try {
      const result = await client.query(`
        SELECT 
          b.branch_id,
          b.name,
          b.created_at,
          c.contact_id,
          c.contact_no_1,
          c.contact_no_2,
          c.address,
          c.email
        FROM branch b
        JOIN contact c ON b.contact_id = c.contact_id
        ORDER BY b.created_at DESC
      `);
      
      res.json({ branches: result.rows });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});


app.post('/api/admin/branches', async (req, res) => {
  // Verify admin authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Admin access required' });
    }

    const { branch_id, name, contact_no_1, contact_no_2, address, email } = req.body;

    // Validation
    if (!branch_id || !name || !contact_no_1 || !address || !email) {
      return res.status(400).json({ message: 'All required fields must be provided' });
    }

    const client = await pool.connect();

    try {
      await client.query('BEGIN');

      // Check if branch already exists
      const branchCheck = await client.query('SELECT * FROM branch WHERE branch_id = $1', [branch_id]);
      if (branchCheck.rows.length > 0) {
        await client.query('ROLLBACK');
        return res.status(400).json({ message: 'Branch ID already exists' });
      }

      // Create contact record (auto-generated ID)
      const contactResult = await client.query(
        `INSERT INTO contact (type, contact_no_1, contact_no_2, address, email)
         VALUES ($1, $2, $3, $4, $5)
         RETURNING contact_id`,
        ['branch', contact_no_1, contact_no_2 || null, address, email]
      );

      const contactId = contactResult.rows[0].contact_id;

      // Create branch record (auto-generated ID)
      const branchResult = await client.query(
        `INSERT INTO branch (name, contact_id)
         VALUES ($1, $2)
         RETURNING branch_id`,
        [name, contactId]
      );

      const newBranchId = branchResult.rows[0].branch_id;

      await client.query('COMMIT');
      
      res.status(201).json({ 
        message: 'Branch created successfully',
        branch_id: newBranchId
      });
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});


// DELETE /api/admin/branches/:id - Delete branch
app.delete('/api/admin/branches/:id', async (req, res) => {
  // Verify admin authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Admin access required' });
    }

    const { id } = req.params;
    const client = await pool.connect();
    
    try {
      await client.query('BEGIN');

      // Get contact_id for the branch
      const branchResult = await client.query('SELECT contact_id FROM branch WHERE branch_id = $1', [id]);
      if (branchResult.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(404).json({ message: 'Branch not found' });
      }

      const contactId = branchResult.rows[0].contact_id;

      // Check if branch has employees
      const employeesCheck = await client.query('SELECT COUNT(*) as count FROM employee WHERE branch_id = $1', [id]);
      if (parseInt(employeesCheck.rows[0].count) > 0) {
        await client.query('ROLLBACK');
        return res.status(400).json({ message: 'Cannot delete branch with assigned employees. Reassign employees first.' });
      }

      // Check if branch has accounts
      const accountsCheck = await client.query('SELECT COUNT(*) as count FROM account WHERE branch_id = $1', [id]);
      if (parseInt(accountsCheck.rows[0].count) > 0) {
        await client.query('ROLLBACK');
        return res.status(400).json({ message: 'Cannot delete branch with associated accounts. Transfer accounts first.' });
      }

      // Delete branch
      await client.query('DELETE FROM branch WHERE branch_id = $1', [id]);
      
      // Delete contact
      await client.query('DELETE FROM contact WHERE contact_id = $1', [contactId]);

      await client.query('COMMIT');
      
      res.json({ message: 'Branch deleted successfully' });
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});


// Customer Registration API
app.post('/api/agent/customers/register', async (req, res) => {
  // Verify agent authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const { first_name, last_name, nic, gender, date_of_birth, contact_no_1, contact_no_2, address, email } = req.body;

    // Validation
    if (!first_name || !last_name || !nic || !gender || !date_of_birth || !contact_no_1 || !address || !email) {
      return res.status(400).json({ message: 'All required fields must be provided' });
    }

    // Age validation removed: allow registering customers under 18

    const client = await pool.connect();

    try {
      await client.query('BEGIN');

      // Check if customer with NIC already exists
      const customerCheck = await client.query('SELECT * FROM customer WHERE nic = $1', [nic]);
      if (customerCheck.rows.length > 0) {
        await client.query('ROLLBACK');
        return res.status(400).json({ message: 'Customer with this NIC already exists' });
      }

      // Create contact record (auto-generated ID)
      const contactResult = await client.query(
        `INSERT INTO contact (type, contact_no_1, contact_no_2, address, email)
         VALUES ($1, $2, $3, $4, $5)
         RETURNING contact_id`,
        ['customer', contact_no_1, contact_no_2 || null, address, email]
      );

      const contactId = contactResult.rows[0].contact_id;

      // Create customer record (auto-generated ID)
      const customerResult = await client.query(
        `INSERT INTO customer (first_name, last_name, gender, nic, date_of_birth, contact_id)
         VALUES ($1, $2, $3, $4, $5, $6)
         RETURNING customer_id`,
        [first_name, last_name, gender, nic, date_of_birth, contactId]
      );

      const customerId = customerResult.rows[0].customer_id;

      await client.query('COMMIT');
      
      res.status(201).json({ 
        message: 'Customer registered successfully',
        customer_id: customerId
      });
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// Get full customer details (with contact) by ID
app.get('/api/agent/customers/:id', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const { id } = req.params;
    const client = await pool.connect();
    try {
      const result = await client.query(`
        SELECT 
          c.customer_id,
          c.first_name,
          c.last_name,
          c.gender,
          c.nic,
          c.date_of_birth,
          ct.contact_id,
          ct.contact_no_1,
          ct.contact_no_2,
          ct.address,
          ct.email
        FROM customer c
        JOIN contact ct ON c.contact_id = ct.contact_id
        WHERE c.customer_id = $1
      `, [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ message: 'Customer not found' });
      }

      res.json({ customer: result.rows[0] });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// Update customer details (and contact)
app.put('/api/agent/customers/:id', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const { id } = req.params;
    const { first_name, last_name, nic, gender, date_of_birth, contact_no_1, contact_no_2, address, email } = req.body;

    // Basic validation
    if (!first_name || !last_name || !nic || !gender || !date_of_birth || !contact_no_1 || !address || !email) {
      return res.status(400).json({ message: 'All required fields must be provided' });
    }

    const dob = new Date(date_of_birth);
    const today = new Date();
    const age = today.getFullYear() - dob.getFullYear();
    if (age < 18) {
      return res.status(400).json({ message: 'Customer must be at least 18 years old' });
    }

    const client = await pool.connect();
    try {
      await client.query('BEGIN');

      // Get existing to retrieve contact_id and current NIC
      const existing = await client.query('SELECT customer_id, contact_id, nic FROM customer WHERE customer_id = $1', [id]);
      if (existing.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(404).json({ message: 'Customer not found' });
      }
      const { contact_id, nic: currentNic } = existing.rows[0];

      // If NIC changed, check uniqueness
      if (nic !== currentNic) {
        const nicCheck = await client.query('SELECT 1 FROM customer WHERE nic = $1 AND customer_id <> $2', [nic, id]);
        if (nicCheck.rows.length > 0) {
          await client.query('ROLLBACK');
          return res.status(400).json({ message: 'Another customer with this NIC already exists' });
        }
      }

      // Update contact
      await client.query(
        `UPDATE contact SET contact_no_1 = $1, contact_no_2 = $2, address = $3, email = $4 WHERE contact_id = $5`,
        [contact_no_1, contact_no_2 || null, address, email, contact_id]
      );

      // Update customer
      await client.query(
        `UPDATE customer SET first_name = $1, last_name = $2, gender = $3, nic = $4, date_of_birth = $5 WHERE customer_id = $6`,
        [first_name, last_name, gender, nic, date_of_birth, id]
      );

      await client.query('COMMIT');

      res.json({ message: 'Customer updated successfully' });
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error: ' + error.message });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});


// Update customer contact details only
app.put('/api/agent/customers/:id/contact', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const { id } = req.params;
    const { contact_no_1, contact_no_2, address, email } = req.body;

    // Validate contact fields only
    if (!contact_no_1 || !address || !email) {
      return res.status(400).json({ message: 'contact_no_1, address and email are required' });
    }
    if (!/^[0-9+]{10,15}$/.test(String(contact_no_1))) {
      return res.status(400).json({ message: 'Invalid primary contact number' });
    }
    if (contact_no_2 && !/^[0-9+]{10,15}$/.test(String(contact_no_2))) {
      return res.status(400).json({ message: 'Invalid secondary contact number' });
    }
    if (!/\S+@\S+\.\S+/.test(String(email))) {
      return res.status(400).json({ message: 'Invalid email address' });
    }

    const client = await pool.connect();
    try {
      await client.query('BEGIN');

      // Set actor for auditing context
      await client.query("SELECT set_config('app.actor_employee_id', $1, true)", [decoded.id.toString()]);

      // Retrieve contact_id for the customer
      const existing = await client.query('SELECT contact_id FROM customer WHERE customer_id = $1', [id]);
      if (existing.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(404).json({ message: 'Customer not found' });
      }
      const { contact_id } = existing.rows[0];

      // Update only contact information
      await client.query(
        `UPDATE contact SET contact_no_1 = $1, contact_no_2 = $2, address = $3, email = $4 WHERE contact_id = $5`,
        [contact_no_1, contact_no_2 || null, address, email, contact_id]
      );

      await client.query('COMMIT');
      res.json({ message: 'Contact details updated successfully' });
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error: ' + error.message });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});


app.get('/api/agent/customers', async (req, res) => {
  // Verify agent authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const client = await pool.connect();
    try {
      const result = await client.query(`
        SELECT customer_id, first_name, last_name, nic, date_of_birth 
        FROM customer 
        ORDER BY first_name, last_name
      `);
      
      res.json({ customers: result.rows });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});
// Get all saving plans
app.get('/api/saving-plans', async (req, res) => {
  const client = await pool.connect();
  try {
    const result = await client.query(`
      SELECT saving_plan_id, plan_type, interest, min_balance 
      FROM savingplan 
      ORDER BY plan_type
    `);
    
    res.json({ saving_plans: result.rows });
  } catch (error) {
    console.error('Database error:', error);
    res.status(500).json({ message: 'Database error' });
  } finally {
    client.release();
  }
});

// Get all branches
app.get('/api/branches', async (req, res) => {
  const client = await pool.connect();
  try {
    const result = await client.query(`
      SELECT branch_id, name 
      FROM branch 
      ORDER BY name
    `);
    
    res.json({ branches: result.rows });
  } catch (error) {
    console.error('Database error:', error);
    res.status(500).json({ message: 'Database error' });
  } finally {
    client.release();
  }
});

// Create account for customer (with joint account support)
app.post('/api/agent/accounts/create', async (req, res) => {
  // Verify agent authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const { customer_id, saving_plan_id, initial_deposit, branch_id, joint_holders = [] } = req.body;

    // Coerce numeric inputs to Numbers (defensive) and validate
    const customerIdNum = Number(customer_id);
    const savingPlanIdNum = Number(saving_plan_id);
    const branchIdNum = Number(branch_id);
    const initialDeposit = Number(initial_deposit);

    // Validation
    if (!customerIdNum || !savingPlanIdNum || !branchIdNum || initial_deposit === undefined) {
      return res.status(400).json({ message: 'All required fields must be provided' });
    }

    if (isNaN(initialDeposit)) {
      return res.status(400).json({ message: 'Invalid initial deposit amount' });
    }

    if (initialDeposit < 0) {
      return res.status(400).json({ message: 'Initial deposit cannot be negative' });
    }

    const client = await pool.connect();

    try {
      await client.query('BEGIN');

      // Get saving plan details for validation
  const planResult = await client.query('SELECT * FROM savingplan WHERE saving_plan_id = $1', [savingPlanIdNum]);
      if (planResult.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(400).json({ message: 'Invalid saving plan' });
      }

      const savingPlan = planResult.rows[0];
      
      // Joint account validation
      if (savingPlan.plan_type === 'Joint' && joint_holders.length === 0) {
        await client.query('ROLLBACK');
        return res.status(400).json({ message: 'Joint account requires at least one joint holder' });
      }

      if (initialDeposit < savingPlan.min_balance) {
        await client.query('ROLLBACK');
        return res.status(400).json({ 
          message: `Minimum deposit for ${savingPlan.plan_type} plan is LKR ${savingPlan.min_balance}` 
        });
      }

      // Verify primary customer exists and meets plan-specific age requirement
      const customerResult = await client.query(
        'SELECT *, EXTRACT(YEAR FROM AGE(date_of_birth)) as age FROM customer WHERE customer_id = $1',
        [customerIdNum]
      );
      if (customerResult.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(400).json({ message: 'Primary customer not found' });
      }

      const primaryCustomer = customerResult.rows[0];
      const planType = savingPlan.plan_type;
      let requiredAge = 18;
      if (planType === 'Senior') requiredAge = 60;
      else if (planType === 'Joint') requiredAge = 18;
  else if (planType === 'Children') requiredAge = 0;
  else if (planType === 'Teen') requiredAge = 12;
      else if (planType === 'Adult') requiredAge = 18;

      if (parseInt(primaryCustomer.age) < requiredAge) {
        await client.query('ROLLBACK');
        return res.status(400).json({ message: `${planType} account requires account holder to be at least ${requiredAge} years old` });
      }

      // Verify joint holders exist and are at least 18 years old
      if (joint_holders.length > 0) {
        const jointHoldersResult = await client.query(
          `SELECT customer_id, first_name, last_name, EXTRACT(YEAR FROM AGE(date_of_birth)) as age 
           FROM customer WHERE customer_id = ANY($1)`,
          [joint_holders]
        );

        if (jointHoldersResult.rows.length !== joint_holders.length) {
          await client.query('ROLLBACK');
          return res.status(400).json({ message: 'One or more joint holders not found' });
        }

        const underageJointHolder = jointHoldersResult.rows.find(holder => parseInt(holder.age) < 18);
        if (underageJointHolder) {
          await client.query('ROLLBACK');
          return res.status(400).json({ 
            message: `Joint holder ${underageJointHolder.first_name} ${underageJointHolder.last_name} must be at least 18 years old` 
          });
        }
      }

      // Verify branch exists
      const branchResult = await client.query('SELECT * FROM branch WHERE branch_id = $1', [branch_id]);
      if (branchResult.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(400).json({ message: 'Branch not found' });
      }

      // Create account with 0 balance initially
      const accountResult = await client.query(
        `INSERT INTO account (open_date, account_status, balance, saving_plan_id, branch_id)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING account_id`,
        [new Date().toISOString().split('T')[0], 'Active', 0, savingPlanIdNum, branchIdNum]  // Start with 0 balance
      );

      const accountId = accountResult.rows[0].account_id;

      // Create takes relationship for primary customer (auto-generated ID)
      await client.query(
        `INSERT INTO takes (customer_id, account_id)
         VALUES ($1, $2)`,
        [customerIdNum, accountId]
      );

      // Create takes relationships for joint holders (auto-generated ID)
      for (const jointCustomerId of joint_holders) {
        await client.query(
          `INSERT INTO takes (customer_id, account_id)
             VALUES ($1, $2)`,
            [jointCustomerId, accountId]
        );
      }

      // Create initial transaction if deposit > 0 using database function
      if (initialDeposit > 0) {
        await client.query(
          'SELECT create_transaction_with_validation($1, $2, $3, $4, $5)',
          ['Deposit', initialDeposit, 'Initial Deposit', accountId, decoded.id]
        );
      }

      await client.query('COMMIT');
      
      res.status(201).json({ 
        message: 'Account created successfully',
        account_id: accountId,
        joint_holders_count: joint_holders.length
      });
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error: ' + error.message });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});
// Get accounts for transaction processing (FIXED for joint accounts)
app.get('/api/agent/accounts', async (req, res) => {
  // Verify agent authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const client = await pool.connect();
    try {
      const result = await client.query(`
        SELECT DISTINCT
          a.account_id,
          a.balance,
          a.account_status,
          STRING_AGG(DISTINCT c.first_name || ' ' || c.last_name, ', ') as customer_names
        FROM account a
        JOIN takes t ON a.account_id = t.account_id
        JOIN customer c ON t.customer_id = c.customer_id
        WHERE a.account_status = 'Active'
        GROUP BY a.account_id, a.balance, a.account_status
        ORDER BY a.account_id
      `);
      
      res.json({ accounts: result.rows });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

app.get('/api/agent/transactions/recent', async (req, res) => {
  // Verify agent authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const client = await pool.connect();
    try {
      const result = await client.query(`
        SELECT 
          transaction_id,
          transaction_type,
          amount,
          time,
          description,
          account_id,
          employee_id
        FROM transaction 
        ORDER BY time DESC 
        LIMIT 50
      `);
      
      res.json({ transactions: result.rows });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});
// Get agent performance metrics
app.get('/api/agent/performance', async (req, res) => {
  // Verify agent authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const client = await pool.connect();
    try {
      const employeeId = decoded.id;
      const today = new Date().toISOString().split('T')[0];
      const currentMonth = new Date().getMonth() + 1;
      const currentYear = new Date().getFullYear();

      // Today's transactions count
      const todayTransactionsResult = await client.query(
        `SELECT COUNT(*) as count FROM transaction 
         WHERE employee_id = $1 AND DATE(time) = $2`,
        [employeeId, today]
      );

      // Total customers registered by this agent
      const totalCustomersResult = await client.query(
        `SELECT COUNT(DISTINCT t.customer_id) as count 
         FROM takes t
         JOIN account a ON t.account_id = a.account_id
         JOIN transaction tr ON a.account_id = tr.account_id
         WHERE tr.employee_id = $1 AND tr.transaction_type = 'Deposit'`,
        [employeeId]
      );

      // Monthly accounts created
      const monthlyAccountsResult = await client.query(
        `SELECT COUNT(DISTINCT a.account_id) as count 
         FROM account a
         JOIN transaction tr ON a.account_id = tr.account_id
         WHERE tr.employee_id = $1 AND EXTRACT(MONTH FROM tr.time) = $2 
         AND EXTRACT(YEAR FROM tr.time) = $3`,
        [employeeId, currentMonth, currentYear]
      );

      // Total transaction volume
      const transactionVolumeResult = await client.query(
        `SELECT COALESCE(SUM(amount), 0) as total 
         FROM transaction 
         WHERE employee_id = $1`,
        [employeeId]
      );

      // Recent activity
      const recentActivityResult = await client.query(
        `SELECT 
          'transaction' as type,
          transaction_type || ' - ' || description as description,
          time
         FROM transaction 
         WHERE employee_id = $1 
         UNION ALL
         SELECT 
          'account' as type,
          'Account created for ' || c.first_name || ' ' || c.last_name as description,
          a.open_date as time
         FROM account a
         JOIN takes t ON a.account_id = t.account_id
         JOIN customer c ON t.customer_id = c.customer_id
         JOIN transaction tr ON a.account_id = tr.account_id
         WHERE tr.employee_id = $1 AND tr.transaction_type = 'Deposit'
         ORDER BY time DESC 
         LIMIT 10`,
        [employeeId]
      );

      const performanceData = {
        today_transactions: parseInt(todayTransactionsResult.rows[0].count),
        total_customers: parseInt(totalCustomersResult.rows[0].count),
        monthly_accounts: parseInt(monthlyAccountsResult.rows[0].count),
        transaction_volume: parseFloat(transactionVolumeResult.rows[0].total),
        recent_activity: recentActivityResult.rows
      };

      res.json(performanceData);
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});


app.get('/api/manager/team/agents', async (req, res) => {
  // Verify manager authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Manager' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Manager access required' });
    }

    const client = await pool.connect();
    try {
      // Get manager's branch
      const managerResult = await client.query(
        'SELECT branch_id FROM employee WHERE employee_id = $1',
        [decoded.id]
      );

      if (managerResult.rows.length === 0) {
        return res.status(404).json({ message: 'Manager not found' });
      }

      const branchId = managerResult.rows[0].branch_id;

      // Get agents in the same branch
      const agentsResult = await client.query(`
        SELECT 
          e.employee_id, e.username, e.first_name, e.last_name, e.role,
          e.nic, e.gender, e.date_of_birth, e.branch_id, e.contact_id, e.created_at,
          c.contact_no_1, c.contact_no_2, c.email, c.address
        FROM employee e
        LEFT JOIN contact c ON e.contact_id = c.contact_id
        WHERE e.branch_id = $1 AND e.role = 'Agent'
        ORDER BY e.first_name, e.last_name
      `, [branchId]);

      // Get performance data for each agent
      const performanceData = {};
      for (const agent of agentsResult.rows) {
        const performanceResult = await client.query(`
          SELECT 
            COUNT(*) as total_transactions,
            COALESCE(SUM(amount), 0) as total_volume,
            COUNT(DISTINCT t.customer_id) as customers_registered,
            COUNT(DISTINCT a.account_id) as accounts_created,
            MAX(tr.time) as last_activity
          FROM transaction tr
          LEFT JOIN account a ON tr.account_id = a.account_id
          LEFT JOIN takes t ON a.account_id = t.account_id
          WHERE tr.employee_id = $1
        `, [agent.employee_id]);

        performanceData[agent.employee_id] = {
          total_transactions: parseInt(performanceResult.rows[0].total_transactions),
          total_volume: parseFloat(performanceResult.rows[0].total_volume),
          customers_registered: parseInt(performanceResult.rows[0].customers_registered),
          accounts_created: parseInt(performanceResult.rows[0].accounts_created),
          last_activity: performanceResult.rows[0].last_activity
        };
      }

      res.json({
        agents: agentsResult.rows,
        performance: performanceData
      });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// Get specific agent's transactions
app.get('/api/manager/team/agents/:agentId/transactions', async (req, res) => {
  // Verify manager authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Manager' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Manager access required' });
    }

    const { agentId } = req.params;
    const client = await pool.connect();
    try {
      const transactionsResult = await client.query(`
        SELECT 
          transaction_id, transaction_type, amount, time, description, account_id, employee_id
        FROM transaction 
        WHERE employee_id = $1
        ORDER BY time DESC
        LIMIT 50
      `, [agentId]);

      res.json({
        transactions: transactionsResult.rows
      });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// Get branch transactions with filters (UPDATED - removed agent summary)
app.get('/api/manager/transactions', async (req, res) => {
  // Verify manager authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Manager' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Manager access required' });
    }

    const { start, end } = req.query;
    const client = await pool.connect();
    try {
      // Get manager's branch
      const managerResult = await client.query(
        'SELECT branch_id FROM employee WHERE employee_id = $1',
        [decoded.id]
      );

      if (managerResult.rows.length === 0) {
        return res.status(404).json({ message: 'Manager not found' });
      }

      const branchId = managerResult.rows[0].branch_id;

      // Get transactions for the branch with agent names
      const transactionsResult = await client.query(`
        SELECT 
          t.transaction_id, t.transaction_type, t.amount, t.time, t.description,
          t.account_id, t.employee_id,
          e.first_name || ' ' || e.last_name as employee_name
        FROM transaction t
        JOIN employee e ON t.employee_id = e.employee_id
        JOIN account a ON t.account_id = a.account_id
        WHERE a.branch_id = $1 
        AND DATE(t.time) BETWEEN $2 AND $3
        ORDER BY t.time DESC
        LIMIT 100
      `, [branchId, start, end]);

      // Get summary data (without agent summary)
      const summaryResult = await client.query(`
        SELECT 
          COUNT(*) as transaction_count,
          COALESCE(SUM(CASE WHEN transaction_type = 'Deposit' THEN amount ELSE 0 END), 0) as total_deposits,
          COALESCE(SUM(CASE WHEN transaction_type = 'Withdrawal' THEN amount ELSE 0 END), 0) as total_withdrawals,
          COALESCE(SUM(CASE WHEN transaction_type = 'Deposit' THEN amount ELSE -amount END), 0) as net_flow
        FROM transaction t
        JOIN account a ON t.account_id = a.account_id
        WHERE a.branch_id = $1 AND DATE(t.time) BETWEEN $2 AND $3
      `, [branchId, start, end]);

      const summary = {
        total_deposits: parseFloat(summaryResult.rows[0].total_deposits),
        total_withdrawals: parseFloat(summaryResult.rows[0].total_withdrawals),
        net_flow: parseFloat(summaryResult.rows[0].net_flow),
        transaction_count: parseInt(summaryResult.rows[0].transaction_count)
      };

      res.json({
        transactions: transactionsResult.rows,
        summary: summary
      });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});
// Get customer accounts for manager's branch
app.get('/api/manager/accounts', async (req, res) => {
  // Verify manager authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Manager' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Manager access required' });
    }

    const client = await pool.connect();
    try {
      // Get manager's branch
      const managerResult = await client.query(
        'SELECT branch_id FROM employee WHERE employee_id = $1',
        [decoded.id]
      );

      if (managerResult.rows.length === 0) {
        return res.status(404).json({ message: 'Manager not found' });
      }

      const branchId = managerResult.rows[0].branch_id;

      // Get accounts with customer and saving plan details
      const accountsResult = await client.query(`
        SELECT 
          a.account_id,
          a.open_date,
          a.account_status,
          a.balance,
          a.branch_id,
          a.saving_plan_id,
          c.customer_id,
          c.first_name,
          c.last_name,
          c.nic,
          c.gender,
          c.date_of_birth,
          ct.contact_no_1,
          ct.email,
          ct.address,
          sp.plan_type,
          sp.interest,
          sp.min_balance
        FROM account a
        JOIN takes t ON a.account_id = t.account_id
        JOIN customer c ON t.customer_id = c.customer_id
        JOIN contact ct ON c.contact_id = ct.contact_id
        LEFT JOIN savingplan sp ON a.saving_plan_id = sp.saving_plan_id
        WHERE a.branch_id = $1
        ORDER BY a.balance DESC
      `, [branchId]);

      // Calculate summary statistics
      const activeAccounts = accountsResult.rows.filter(acc => acc.account_status === 'Active');
      const totalBalance = activeAccounts.reduce((sum, acc) => sum + parseFloat(acc.balance), 0);
      
      const summary = {
        total_accounts: accountsResult.rows.length,
        active_accounts: activeAccounts.length,
        closed_accounts: accountsResult.rows.length - activeAccounts.length,
        total_balance: totalBalance,
        average_balance: activeAccounts.length > 0 ? totalBalance / activeAccounts.length : 0
      };

      res.json({
        accounts: accountsResult.rows,
        summary: summary
      });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// FD Plans
// Get all FD plans
app.get('/api/fd-plans', async (req, res) => {
  const client = await pool.connect();
  try {
    const result = await client.query(`
      SELECT fd_plan_id, fd_options, interest 
      FROM fdplan 
      ORDER BY fd_options
    `);
    
    res.json({ fd_plans: result.rows });
  } catch (error) {
    console.error('Database error:', error);
    res.status(500).json({ message: 'Database error' });
  } finally {
    client.release();
  }
});


// Get accounts with FD information (updated to exclude joint accounts)
app.get('/api/agent/accounts-with-fd', async (req, res) => {
  // Verify agent authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const client = await pool.connect();
    try {
      
      const result = await client.query(`
        SELECT 
          a.account_id,
          a.balance,
          a.account_status,
          a.fd_id,
          sp.plan_type,
          sp.min_balance,
          sp.interest,
          (
            SELECT STRING_AGG(c.first_name || ' ' || c.last_name, ', ')
            FROM takes t2
            JOIN customer c ON t2.customer_id = c.customer_id
            WHERE t2.account_id = a.account_id
          ) as customer_names,
          (
            SELECT COUNT(DISTINCT customer_id)
            FROM takes t3
            WHERE t3.account_id = a.account_id
          ) as customer_count
        FROM account a
        JOIN savingplan sp ON a.saving_plan_id = sp.saving_plan_id
        WHERE a.account_status = 'Active'
        ORDER BY a.account_id
      `);
      
      res.json({ accounts: result.rows });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// Get all fixed deposits
app.get('/api/agent/fixed-deposits', async (req, res) => {
  // Verify agent authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const client = await pool.connect();
    try {
      const result = await client.query(`
        SELECT 
          fd.fd_id,
          fd.fd_balance,
          fd.fd_status,
          fd.open_date,
          fd.maturity_date,
          fd.auto_renewal_status,
          fp.fd_options,
          fp.interest,
          a.account_id,
          STRING_AGG(DISTINCT c.first_name || ' ' || c.last_name, ', ') as customer_names,
          STRING_AGG(DISTINCT c.nic, ',') as customer_nics
        FROM fixeddeposit fd
        JOIN fdplan fp ON fd.fd_plan_id = fp.fd_plan_id
        JOIN account a ON fd.fd_id = a.fd_id
        JOIN takes t ON a.account_id = t.account_id
        JOIN customer c ON t.customer_id = c.customer_id
        GROUP BY fd.fd_id, fd.fd_balance, fd.fd_status, fd.open_date, fd.maturity_date, 
                 fd.auto_renewal_status, fp.fd_options, fp.interest, a.account_id
        ORDER BY fd.open_date DESC
      `);
      
      res.json({ fixed_deposits: result.rows });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// Enhanced search fixed deposits - supports FD ID, customer name, and account ID
app.get('/api/agent/fixed-deposits/search', async (req, res) => {
  // Verify agent authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const { query } = req.query;
    
    if (!query) {
      return res.status(400).json({ message: 'Search query is required' });
    }

    const client = await pool.connect();
    try {
      const result = await client.query(`
        SELECT 
          fd.fd_id,
          fd.fd_balance,
          fd.fd_status,
          fd.open_date,
          fd.maturity_date,
          fd.auto_renewal_status,
          fp.fd_options,
          fp.interest,
          a.account_id,
          STRING_AGG(DISTINCT c.first_name || ' ' || c.last_name, ', ') as customer_names,
          STRING_AGG(DISTINCT c.nic, ',') as customer_nics
        FROM fixeddeposit fd
        JOIN fdplan fp ON fd.fd_plan_id = fp.fd_plan_id
        JOIN account a ON fd.fd_id = a.fd_id
        JOIN takes t ON a.account_id = t.account_id
        JOIN customer c ON t.customer_id = c.customer_id
        WHERE 
          CAST(fd.fd_id AS TEXT) ILIKE $1 OR 
          c.nic ILIKE $1
        GROUP BY fd.fd_id, fd.fd_balance, fd.fd_status, fd.open_date, fd.maturity_date, 
                 fd.auto_renewal_status, fp.fd_options, fp.interest, a.account_id
        ORDER BY fd.open_date DESC
      `, [`%${query}%`]);
      
      res.json({ fixed_deposits: result.rows });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// Deactivate fixed deposit - FIXED VERSION (returns principal amount)
app.post('/api/agent/fixed-deposits/deactivate', async (req, res) => {
  // Verify agent authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const { fd_id } = req.body;

    if (!fd_id) {
      return res.status(400).json({ message: 'FD ID is required' });
    }

    const client = await pool.connect();

    try {
      await client.query('BEGIN');

      // Check if FD exists and is active
      const fdResult = await client.query(
        'SELECT * FROM fixeddeposit WHERE fd_id = $1 AND fd_status = $2',
        [fd_id, 'Active']
      );

      if (fdResult.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(400).json({ message: 'Active fixed deposit not found' });
      }

      const fd = fdResult.rows[0];

      // Get the linked account ID
      const accountResult = await client.query(
        'SELECT account_id FROM account WHERE fd_id = $1',
        [fd_id]
      );
      
      if (accountResult.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(400).json({ message: 'Linked savings account not found' });
      }

      const accountId = accountResult.rows[0].account_id;

      // âœ… Return principal amount via validated transaction (single source of truth)
      await client.query(
        'SELECT create_transaction_with_validation($1, $2, $3, $4, $5)',
        ['Deposit', fd.fd_balance, 
         `FD Deactivation - Principal Return (${fd_id})`, accountId, decoded.id]
      );

      // Update FD status to Closed
      await client.query(
        'UPDATE fixeddeposit SET fd_status = $1 WHERE fd_id = $2',
        ['Closed', fd_id]
      );

      // Remove FD reference from account
      await client.query(
        'UPDATE account SET fd_id = NULL WHERE fd_id = $1',
        [fd_id]
      );

      await client.query('COMMIT');
      
      res.json({ 
        message: 'Fixed deposit deactivated successfully. Principal amount returned to savings account.',
        fd_id: fd_id,
        principal_returned: fd.fd_balance,
        account_id: accountId
      });
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error: ' + error.message });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// Account management
// Get all accounts with basic information
app.get('/api/agent/all-accounts', async (req, res) => {
  // Verify agent authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const client = await pool.connect();
    try {
      const result = await client.query(`
        SELECT 
          a.account_id,
          a.balance,
          a.account_status,
          a.open_date,
          a.branch_id,
          a.saving_plan_id,
          a.fd_id,
          sp.plan_type,
          sp.interest,
          sp.min_balance,
          STRING_AGG(DISTINCT c.first_name || ' ' || c.last_name, ', ') as customer_names,
          STRING_AGG(DISTINCT c.nic, ',') as customer_nics,
          COUNT(DISTINCT t.customer_id) as customer_count
        FROM account a
        JOIN takes t ON a.account_id = t.account_id
        JOIN customer c ON t.customer_id = c.customer_id
        JOIN savingplan sp ON a.saving_plan_id = sp.saving_plan_id
        GROUP BY a.account_id, a.balance, a.account_status, a.open_date, a.branch_id, 
                 a.saving_plan_id, a.fd_id, sp.plan_type, sp.interest, sp.min_balance
        ORDER BY a.open_date DESC
      `);
      
      res.json({ accounts: result.rows });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// Get detailed account information
app.get('/api/agent/accounts/:accountId/details', async (req, res) => {
  // Verify agent authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const { accountId } = req.params;
    const client = await pool.connect();
    try {
      // Get basic account information with branch name
      const accountResult = await client.query(`
        SELECT 
          a.account_id,
          a.balance,
          a.account_status,
          a.open_date,
          b.name as branch_name,
          sp.plan_type,
          sp.interest,
          sp.min_balance
        FROM account a
        JOIN branch b ON a.branch_id = b.branch_id
        JOIN savingplan sp ON a.saving_plan_id = sp.saving_plan_id
        WHERE a.account_id = $1
      `, [accountId]);

      if (accountResult.rows.length === 0) {
        return res.status(404).json({ message: 'Account not found' });
      }

      const account = accountResult.rows[0];

      // Get customer information
      const customersResult = await client.query(`
        SELECT 
          c.customer_id,
          c.first_name,
          c.last_name,
          c.nic,
          c.date_of_birth
        FROM customer c
        JOIN takes t ON c.customer_id = t.customer_id
        WHERE t.account_id = $1
      `, [accountId]);

      // Get recent transactions (last 20)
      const transactionsResult = await client.query(`
        SELECT 
          transaction_id,
          transaction_type,
          amount,
          time,
          description
        FROM transaction 
        WHERE account_id = $1
        ORDER BY time DESC
        LIMIT 20
      `, [accountId]);

      const accountDetails = {
        ...account,
        customers: customersResult.rows,
        transactions: transactionsResult.rows
      };

      res.json({ account: accountDetails });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// Search accounts by account ID or customer name
app.get('/api/agent/accounts/search/:searchTerm', async (req, res) => {
  // Verify agent authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const { searchTerm } = req.params;
    const client = await pool.connect();
    try {
      const result = await client.query(`
        SELECT 
          a.account_id,
          a.balance,
          a.account_status,
          a.open_date,
          a.branch_id,
          a.saving_plan_id,
          a.fd_id,
          sp.plan_type,
          sp.interest,
          sp.min_balance,
          STRING_AGG(DISTINCT c.first_name || ' ' || c.last_name, ', ') as customer_names,
          COUNT(DISTINCT t.customer_id) as customer_count,
          b.name as branch_name
        FROM account a
        JOIN takes t ON a.account_id = t.account_id
        JOIN customer c ON t.customer_id = c.customer_id
        JOIN savingplan sp ON a.saving_plan_id = sp.saving_plan_id
        JOIN branch b ON a.branch_id = b.branch_id
        WHERE a.account_id ILIKE $1 OR c.first_name ILIKE $1 OR c.last_name ILIKE $1
        GROUP BY a.account_id, a.balance, a.account_status, a.open_date, a.branch_id, 
                 a.saving_plan_id, a.fd_id, sp.plan_type, sp.interest, sp.min_balance, b.name
        ORDER BY a.open_date DESC
      `, [`%${searchTerm}%`]);
      
      res.json({ accounts: result.rows });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// Change account saving plan (Agent/Admin)
app.post('/api/agent/accounts/change-plan', async (req, res) => {
  // Verify agent/admin authorization
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  const { account_id, new_saving_plan_id, reason, new_nic } = req.body || {};

  if (!account_id || !new_saving_plan_id || typeof reason !== 'string' || reason.trim().length === 0) {
    return res.status(400).json({ message: 'account_id, new_saving_plan_id and non-empty reason are required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Agent' && decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Agent access required' });
    }

    const client = await pool.connect();
    try {
      await client.query('BEGIN');

      // Set actor for auditing context (used by other triggers/logs)
      await client.query("SELECT set_config('app.actor_employee_id', $1, true)", [decoded.id.toString()]);

      // Perform plan change via DB function (handles all validation and audit)
      await client.query('SELECT change_account_saving_plan($1, $2, $3, $4, $5)', [
        Number(account_id),
        Number(new_saving_plan_id),
        Number(decoded.id),
        reason,
        new_nic ?? null
      ]);

      // Return updated plan info for convenience
      const planInfo = await client.query(
        'SELECT saving_plan_id, plan_type, interest, min_balance FROM savingplan WHERE saving_plan_id = $1',
        [Number(new_saving_plan_id)]
      );

      await client.query('COMMIT');

      res.json({
        message: 'Plan changed successfully',
        new_plan: planInfo.rows[0]
      });
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Change plan error:', error);
      // Most validation errors are thrown as exceptions by the DB function
      return res.status(400).json({ message: error.message || 'Failed to change plan' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});


// Interest summary endpoints
// Get FD interest summary
app.get('/api/admin/fd-interest/summary', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Admin access required' });
    }

    const client = await pool.connect();
    try {
      // Total interest paid this month
      const monthlyInterest = await client.query(`
        SELECT COALESCE(SUM(interest_amount), 0) as total_interest
        FROM fd_interest_calculations 
        WHERE status = 'credited' 
        AND EXTRACT(MONTH FROM credited_at) = EXTRACT(MONTH FROM CURRENT_DATE)
        AND EXTRACT(YEAR FROM credited_at) = EXTRACT(YEAR FROM CURRENT_DATE)
      `);

      // Active FDs count and total value
      const activeFDs = await client.query(`
        SELECT COUNT(*) as active_count, COALESCE(SUM(fd_balance), 0) as total_value
        FROM fixeddeposit 
        WHERE fd_status = 'Active'
      `);

      // Recent processing dates (last 5 days when interest was credited)
      const recentPeriods = await client.query(`
        SELECT 
          credited_at::date AS period_start,
          credited_at::date AS period_end,
          MAX(credited_at) AS processed_at
        FROM fd_interest_calculations 
        WHERE status = 'credited'
        GROUP BY credited_at::date
        ORDER BY credited_at::date DESC
        LIMIT 5
      `);

      res.json({
        monthly_interest: parseFloat(monthlyInterest.rows[0].total_interest),
        active_fds: {
          count: parseInt(activeFDs.rows[0].active_count),
          total_value: parseFloat(activeFDs.rows[0].total_value)
        },
        recent_periods: recentPeriods.rows,
        next_scheduled_run: 'Daily at 3:00 AM'
      });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});


// Get savings interest summary
app.get('/api/admin/savings-interest/summary', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Admin access required' });
    }

    const client = await pool.connect();
    try {
      // Total interest paid this month
      const monthlyInterest = await client.query(`
        SELECT COALESCE(SUM(interest_amount), 0) as total_interest
        FROM savings_interest_calculations 
        WHERE status = 'credited' 
        AND EXTRACT(MONTH FROM credited_at) = EXTRACT(MONTH FROM CURRENT_DATE)
        AND EXTRACT(YEAR FROM credited_at) = EXTRACT(YEAR FROM CURRENT_DATE)
      `);

      // Active savings accounts count and total balance
      const activeSavingsAccounts = await client.query(`
        SELECT COUNT(*) as active_count, COALESCE(SUM(balance), 0) as total_balance
        FROM account 
        WHERE account_status = 'Active' 
        AND fd_id IS NULL
        AND balance >= (
          SELECT min_balance FROM savingplan sp 
          WHERE sp.saving_plan_id = account.saving_plan_id
        )
      `);

      // Recent processing dates (last 5 days when interest was credited)
      const recentPeriods = await client.query(`
        SELECT 
          credited_at::date AS period_start,
          credited_at::date AS period_end,
          MAX(credited_at) AS processed_at
        FROM savings_interest_calculations 
        WHERE status = 'credited'
        GROUP BY credited_at::date
        ORDER BY credited_at::date DESC
        LIMIT 5
      `);

      res.json({
        monthly_interest: parseFloat(monthlyInterest.rows[0].total_interest),
        active_savings_accounts: {
          count: parseInt(activeSavingsAccounts.rows[0].active_count),
          total_balance: parseFloat(activeSavingsAccounts.rows[0].total_balance)
        },
        recent_periods: recentPeriods.rows,
        next_scheduled_run: 'Daily at 3:30 AM'
      });
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// Report endpoints
// Agent-wise total number and value of transactions
app.get('/api/admin/reports/agent-transactions', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Admin access required' });
    }

    const { startDate, endDate } = req.query;
    const client = await pool.connect();
    
    try {
      const result = await client.query(`
        SELECT 
          e.employee_id,
          e.first_name || ' ' || e.last_name as employee_name,
          COUNT(t.transaction_id) as total_transactions,
          COALESCE(SUM(CASE WHEN t.transaction_type = 'Deposit' THEN t.amount ELSE 0 END), 0) as total_deposits,
          COALESCE(SUM(CASE WHEN t.transaction_type = 'Withdrawal' THEN t.amount ELSE 0 END), 0) as total_withdrawals,
          COALESCE(SUM(CASE WHEN t.transaction_type = 'Deposit' THEN t.amount ELSE -t.amount END), 0) as net_value
        FROM employee e
        LEFT JOIN transaction t ON e.employee_id = t.employee_id
          AND DATE(t.time) BETWEEN $1 AND $2
        WHERE e.role = 'Agent'
        GROUP BY e.employee_id, e.first_name, e.last_name
        ORDER BY total_transactions DESC
      `, [startDate, endDate]);

      res.json(result.rows);
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// Account-wise transaction summary and current balance
app.get('/api/admin/reports/account-summaries', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Admin access required' });
    }

    const { startDate, endDate } = req.query;
    const client = await pool.connect();
    
    try {
      const result = await client.query(`
        SELECT 
          a.account_id,
          STRING_AGG(DISTINCT c.first_name || ' ' || c.last_name, ', ') as customer_names,
          COUNT(t.transaction_id) as transaction_count,
          COALESCE(SUM(CASE WHEN t.transaction_type = 'Deposit' THEN t.amount ELSE 0 END), 0) as total_deposits,
          COALESCE(SUM(CASE WHEN t.transaction_type = 'Withdrawal' THEN t.amount ELSE 0 END), 0) as total_withdrawals,
          a.balance as current_balance
        FROM account a
        JOIN takes tk ON a.account_id = tk.account_id
        JOIN customer c ON tk.customer_id = c.customer_id
        LEFT JOIN transaction t ON a.account_id = t.account_id
          AND DATE(t.time) BETWEEN $1 AND $2
        WHERE a.account_status = 'Active'
        GROUP BY a.account_id, a.balance
        ORDER BY a.account_id
      `, [startDate, endDate]);

      res.json(result.rows);
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});


// List of active FDs and their next interest payout dates
app.get('/api/admin/reports/active-fds', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Admin access required' });
  }

    const client = await pool.connect();
    
    try {
      const result = await client.query(`
        WITH last_credited AS (
          SELECT fd_id, MAX(calculation_date) AS last_date
          FROM fd_interest_calculations
          WHERE status = 'credited'
          GROUP BY fd_id
        )
        SELECT 
          fd.fd_id,
          a.account_id,
          STRING_AGG(DISTINCT c.first_name || ' ' || c.last_name, ', ') as customer_names,
          fd.fd_balance,
          fp.interest as interest_rate,
          fd.open_date,
          fd.maturity_date,
          fd.auto_renewal_status,
          (COALESCE(l.last_date, fd.open_date) + INTERVAL '30 days')::date AS next_interest_date
        FROM fixeddeposit fd
        JOIN fdplan fp ON fd.fd_plan_id = fp.fd_plan_id
        JOIN account a ON fd.fd_id = a.fd_id
        JOIN takes t ON a.account_id = t.account_id
        JOIN customer c ON t.customer_id = c.customer_id
        LEFT JOIN last_credited l ON l.fd_id = fd.fd_id
        WHERE fd.fd_status = 'Active'
        GROUP BY fd.fd_id, a.account_id, fd.fd_balance, fp.interest, fd.open_date, fd.maturity_date, fd.auto_renewal_status, l.last_date
        ORDER BY fd.open_date DESC
      `);

      res.json(result.rows);
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// Monthly interest distribution summary by account type
app.get('/api/admin/reports/interest-summary', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Admin access required' });
    }

    const { month, year } = req.query;
    const client = await pool.connect();
    
    try {
      // FD Interest Summary
      const fdInterest = await client.query(`
        SELECT 
          'Fixed Deposit' as plan_type,
          fp.fd_options as account_type,
          COALESCE(SUM(fic.interest_amount), 0) as total_interest,
          COUNT(DISTINCT fic.fd_id) as account_count,
          COALESCE(ROUND(AVG(fic.interest_amount), 2), 0) as average_interest
        FROM fd_interest_calculations fic
        JOIN fixeddeposit fd ON fic.fd_id = fd.fd_id
        JOIN fdplan fp ON fd.fd_plan_id = fp.fd_plan_id
        WHERE fic.status = 'credited'
          AND EXTRACT(MONTH FROM fic.credited_at) = $1
          AND EXTRACT(YEAR FROM fic.credited_at) = $2
        GROUP BY fp.fd_options
      `, [month, year]);

      // Savings Interest Summary
      const savingsInterest = await client.query(`
        SELECT 
          'Savings' as plan_type,
          sic.plan_type as account_type,
          COALESCE(SUM(sic.interest_amount), 0) as total_interest,
          COUNT(DISTINCT sic.account_id) as account_count,
          COALESCE(ROUND(AVG(sic.interest_amount), 2), 0) as average_interest
        FROM savings_interest_calculations sic
        WHERE sic.status = 'credited'
          AND EXTRACT(MONTH FROM sic.credited_at) = $1
          AND EXTRACT(YEAR FROM sic.credited_at) = $2
        GROUP BY sic.plan_type
      `, [month, year]);

      const combinedResults = [...fdInterest.rows, ...savingsInterest.rows];
      res.json(combinedResults);
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

// Customer activity report
app.get('/api/admin/reports/customer-activity', async (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Authorization required' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'hey');
    if (decoded.role !== 'Admin') {
      return res.status(403).json({ message: 'Admin access required' });
    }

    const { startDate, endDate } = req.query;
    const client = await pool.connect();
    
    try {
      const result = await client.query(`
        SELECT 
          c.customer_id,
          c.first_name || ' ' || c.last_name as customer_name,
          COUNT(DISTINCT t.account_id) as account_count,
          COALESCE(SUM(CASE WHEN t.transaction_type = 'Deposit' THEN t.amount ELSE 0 END), 0) as total_deposits,
          COALESCE(SUM(CASE WHEN t.transaction_type = 'Withdrawal' THEN t.amount ELSE 0 END), 0) as total_withdrawals,
          COALESCE(SUM(CASE WHEN t.transaction_type = 'Deposit' THEN t.amount ELSE -t.amount END), 0) as net_balance,
          MAX(t.time) as last_activity
        FROM customer c
        JOIN takes tk ON c.customer_id = tk.customer_id
        JOIN account a ON tk.account_id = a.account_id
        LEFT JOIN transaction t ON a.account_id = t.account_id
          AND DATE(t.time) BETWEEN $1 AND $2
        GROUP BY c.customer_id, c.first_name, c.last_name
        ORDER BY net_balance DESC
      `, [startDate, endDate]);

      res.json(result.rows);
    } catch (error) {
      console.error('Database error:', error);
      res.status(500).json({ message: 'Database error' });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ message: 'Invalid or expired token' });
  }
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});